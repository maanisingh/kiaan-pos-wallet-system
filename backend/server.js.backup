const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(require('morgan')('dev'));

// Database connection
const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
});

// Test database connection
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('‚ùå Database connection failed:', err);
  } else {
    console.log('‚úÖ Database connected successfully');
  }
});

// ==================== CUSTOMERS API ====================

// Get all customers
app.get('/api/customers', async (req, res) => {
  try {
    const { search, status } = req.query;
    let query = 'SELECT * FROM customers';
    const params = [];

    if (search || status) {
      query += ' WHERE';
      const conditions = [];

      if (search) {
        conditions.push(` (name ILIKE $${params.length + 1} OR phone ILIKE $${params.length + 1} OR email ILIKE $${params.length + 1})`);
        params.push(`%${search}%`);
      }

      if (status) {
        conditions.push(` status = $${params.length + 1}`);
        params.push(status);
      }

      query += conditions.join(' AND');
    }

    query += ' ORDER BY created_at DESC';

    const result = await pool.query(query, params);
    res.json({ data: result.rows, total: result.rowCount });
  } catch (error) {
    console.error('Error fetching customers:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get customer by ID with full details
app.get('/api/customers/:id', async (req, res) => {
  try {
    const { id } = req.params;

    // Get customer
    const customerResult = await pool.query(
      'SELECT * FROM customers WHERE id = $1',
      [id]
    );

    if (customerResult.rows.length === 0) {
      return res.status(404).json({ error: 'Customer not found' });
    }

    const customer = customerResult.rows[0];

    // Get customer's cards
    const cardsResult = await pool.query(
      'SELECT * FROM nfc_cards WHERE customer_id = $1',
      [id]
    );

    // Get customer's transactions
    const transactionsResult = await pool.query(
      `SELECT t.*, c.card_uid
       FROM card_transactions t
       LEFT JOIN nfc_cards c ON t.card_uid = c.card_uid
       WHERE t.customer_id = $1
       ORDER BY t.created_at DESC
       LIMIT 50`,
      [id]
    );

    // Calculate statistics
    const statsResult = await pool.query(
      `SELECT
        COUNT(*) as total_transactions,
        SUM(CASE WHEN transaction_type = 'purchase' THEN amount ELSE 0 END) as total_spent,
        SUM(CASE WHEN transaction_type = 'topup' THEN amount ELSE 0 END) as total_topup
       FROM card_transactions
       WHERE customer_id = $1`,
      [id]
    );

    res.json({
      data: {
        ...customer,
        cards: cardsResult.rows,
        recent_transactions: transactionsResult.rows,
        statistics: statsResult.rows[0]
      }
    });
  } catch (error) {
    console.error('Error fetching customer:', error);
    res.status(500).json({ error: error.message });
  }
});

// Create customer
app.post('/api/customers', async (req, res) => {
  try {
    const { name, email, phone, address, city, country } = req.body;

    if (!name || !phone) {
      return res.status(400).json({ error: 'Name and phone are required' });
    }

    const result = await pool.query(
      `INSERT INTO customers (name, email, phone, address, city, country)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [name, email, phone, address, city, country || 'Uganda']
    );

    res.status(201).json({ data: result.rows[0] });
  } catch (error) {
    console.error('Error creating customer:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update customer
app.put('/api/customers/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, email, phone, address, city, country, status } = req.body;

    const result = await pool.query(
      `UPDATE customers
       SET name = COALESCE($1, name),
           email = COALESCE($2, email),
           phone = COALESCE($3, phone),
           address = COALESCE($4, address),
           city = COALESCE($5, city),
           country = COALESCE($6, country),
           status = COALESCE($7, status),
           updated_at = NOW()
       WHERE id = $8
       RETURNING *`,
      [name, email, phone, address, city, country, status, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Customer not found' });
    }

    res.json({ data: result.rows[0] });
  } catch (error) {
    console.error('Error updating customer:', error);
    res.status(500).json({ error: error.message });
  }
});

// Delete customer
app.delete('/api/customers/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      'DELETE FROM customers WHERE id = $1 RETURNING *',
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Customer not found' });
    }

    res.json({ message: 'Customer deleted successfully' });
  } catch (error) {
    console.error('Error deleting customer:', error);
    res.status(500).json({ error: error.message });
  }
});

// ==================== NFC CARDS API ====================

// Get all cards
app.get('/api/cards', async (req, res) => {
  try {
    const { status, customer_id } = req.query;
    let query = `
      SELECT c.*, cust.name as customer_name, cust.phone as customer_phone
      FROM nfc_cards c
      LEFT JOIN customers cust ON c.customer_id = cust.id
    `;
    const params = [];

    if (status || customer_id) {
      query += ' WHERE';
      const conditions = [];

      if (status) {
        conditions.push(` c.status = $${params.length + 1}`);
        params.push(status);
      }

      if (customer_id) {
        conditions.push(` c.customer_id = $${params.length + 1}`);
        params.push(customer_id);
      }

      query += conditions.join(' AND');
    }

    query += ' ORDER BY c.created_at DESC';

    const result = await pool.query(query, params);
    res.json({ data: result.rows, total: result.rowCount });
  } catch (error) {
    console.error('Error fetching cards:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get card by ID with transactions
app.get('/api/cards/:id', async (req, res) => {
  try {
    const { id } = req.params;

    // Get card
    const cardResult = await pool.query(
      `SELECT c.*, cust.name as customer_name, cust.phone as customer_phone, cust.email as customer_email
       FROM nfc_cards c
       LEFT JOIN customers cust ON c.customer_id = cust.id
       WHERE c.id = $1`,
      [id]
    );

    if (cardResult.rows.length === 0) {
      return res.status(404).json({ error: 'Card not found' });
    }

    const card = cardResult.rows[0];

    // Get card transactions
    const transactionsResult = await pool.query(
      `SELECT * FROM card_transactions
       WHERE card_uid = $1
       ORDER BY created_at DESC
       LIMIT 100`,
      [card.card_uid]
    );

    res.json({
      data: {
        ...card,
        transactions: transactionsResult.rows
      }
    });
  } catch (error) {
    console.error('Error fetching card:', error);
    res.status(500).json({ error: error.message });
  }
});

// Issue new card
app.post('/api/cards', async (req, res) => {
  try {
    const { card_uid, customer_id, pin, initial_balance } = req.body;

    if (!card_uid || !customer_id || !pin) {
      return res.status(400).json({ error: 'card_uid, customer_id, and pin are required' });
    }

    // Hash PIN
    const pin_hash = await bcrypt.hash(pin, 10);

    const result = await pool.query(
      `INSERT INTO nfc_cards (card_uid, customer_id, balance, pin_hash)
       VALUES ($1, $2, $3, $4)
       RETURNING *`,
      [card_uid, customer_id, initial_balance || 0, pin_hash]
    );

    res.status(201).json({ data: result.rows[0] });
  } catch (error) {
    console.error('Error issuing card:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update card (e.g., block/unblock)
app.put('/api/cards/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { status, blocked_reason } = req.body;

    const result = await pool.query(
      `UPDATE nfc_cards
       SET status = COALESCE($1, status),
           blocked_reason = COALESCE($2, blocked_reason),
           blocked_at = CASE WHEN $1 = 'blocked' THEN NOW() ELSE blocked_at END,
           updated_at = NOW()
       WHERE id = $3
       RETURNING *`,
      [status, blocked_reason, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Card not found' });
    }

    res.json({ data: result.rows[0] });
  } catch (error) {
    console.error('Error updating card:', error);
    res.status(500).json({ error: error.message });
  }
});

// ==================== TRANSACTIONS API ====================

// Get all transactions
app.get('/api/transactions', async (req, res) => {
  try {
    const { card_uid, customer_id, transaction_type, start_date, end_date, limit = 100 } = req.query;

    let query = `
      SELECT t.*,
             c.card_uid,
             cust.name as customer_name,
             cust.phone as customer_phone
      FROM card_transactions t
      LEFT JOIN nfc_cards c ON t.card_uid = c.card_uid
      LEFT JOIN customers cust ON t.customer_id = cust.id
    `;
    const params = [];

    const conditions = [];
    if (card_uid) {
      conditions.push(`t.card_uid = $${params.length + 1}`);
      params.push(card_uid);
    }
    if (customer_id) {
      conditions.push(`t.customer_id = $${params.length + 1}`);
      params.push(customer_id);
    }
    if (transaction_type) {
      conditions.push(`t.transaction_type = $${params.length + 1}`);
      params.push(transaction_type);
    }
    if (start_date) {
      conditions.push(`t.created_at >= $${params.length + 1}`);
      params.push(start_date);
    }
    if (end_date) {
      conditions.push(`t.created_at <= $${params.length + 1}`);
      params.push(end_date);
    }

    if (conditions.length > 0) {
      query += ' WHERE ' + conditions.join(' AND ');
    }

    query += ` ORDER BY t.created_at DESC LIMIT $${params.length + 1}`;
    params.push(limit);

    const result = await pool.query(query, params);
    res.json({ data: result.rows, total: result.rowCount });
  } catch (error) {
    console.error('Error fetching transactions:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get transaction by ID
app.get('/api/transactions/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      `SELECT t.*,
              c.card_uid,
              c.balance as current_balance,
              cust.name as customer_name,
              cust.phone as customer_phone,
              cust.email as customer_email
       FROM card_transactions t
       LEFT JOIN nfc_cards c ON t.card_uid = c.card_uid
       LEFT JOIN customers cust ON t.customer_id = cust.id
       WHERE t.id = $1`,
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Transaction not found' });
    }

    res.json({ data: result.rows[0] });
  } catch (error) {
    console.error('Error fetching transaction:', error);
    res.status(500).json({ error: error.message });
  }
});

// Create transaction (purchase)
app.post('/api/transactions', async (req, res) => {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    const { card_uid, amount, transaction_type, description, pin } = req.body;

    if (!card_uid || !amount || !transaction_type) {
      return res.status(400).json({ error: 'card_uid, amount, and transaction_type are required' });
    }

    // Get card
    const cardResult = await client.query(
      'SELECT * FROM nfc_cards WHERE card_uid = $1',
      [card_uid]
    );

    if (cardResult.rows.length === 0) {
      return res.status(404).json({ error: 'Card not found' });
    }

    const card = cardResult.rows[0];

    // Verify card is active
    if (card.status !== 'active') {
      return res.status(400).json({ error: `Card is ${card.status}` });
    }

    // Verify PIN if provided
    if (pin) {
      const validPin = await bcrypt.compare(pin, card.pin_hash);
      if (!validPin) {
        return res.status(401).json({ error: 'Invalid PIN' });
      }
    }

    const balanceBefore = parseFloat(card.balance);
    let balanceAfter = balanceBefore;

    // Calculate new balance
    if (transaction_type === 'purchase') {
      if (balanceBefore < amount) {
        return res.status(400).json({ error: 'Insufficient balance' });
      }
      balanceAfter = balanceBefore - amount;
    } else if (transaction_type === 'topup' || transaction_type === 'refund') {
      balanceAfter = balanceBefore + parseFloat(amount);
    }

    // Create transaction
    const transactionResult = await client.query(
      `INSERT INTO card_transactions
       (card_uid, customer_id, transaction_type, amount, balance_before, balance_after, description, reference_number)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
       RETURNING *`,
      [
        card_uid,
        card.customer_id,
        transaction_type,
        amount,
        balanceBefore,
        balanceAfter,
        description,
        `TXN${Date.now()}`
      ]
    );

    // Update card balance
    await client.query(
      'UPDATE nfc_cards SET balance = $1, last_used_at = NOW() WHERE card_uid = $2',
      [balanceAfter, card_uid]
    );

    await client.query('COMMIT');

    res.status(201).json({ data: transactionResult.rows[0] });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error creating transaction:', error);
    res.status(500).json({ error: error.message });
  } finally {
    client.release();
  }
});

// ==================== DASHBOARD/ANALYTICS API ====================

// Get dashboard statistics
app.get('/api/dashboard/stats', async (req, res) => {
  try {
    const stats = await pool.query(`
      SELECT
        (SELECT COUNT(*) FROM customers WHERE status = 'active') as total_customers,
        (SELECT COUNT(*) FROM nfc_cards WHERE status = 'active') as total_active_cards,
        (SELECT COUNT(*) FROM card_transactions WHERE DATE(created_at) = CURRENT_DATE) as todays_transactions,
        (SELECT COALESCE(SUM(amount), 0) FROM card_transactions WHERE DATE(created_at) = CURRENT_DATE) as todays_revenue,
        (SELECT COALESCE(SUM(balance), 0) FROM nfc_cards WHERE status = 'active') as total_card_balance
    `);

    // Get recent transactions
    const recentTransactions = await pool.query(`
      SELECT t.*,
             c.card_uid,
             cust.name as customer_name
      FROM card_transactions t
      LEFT JOIN nfc_cards c ON t.card_uid = c.card_uid
      LEFT JOIN customers cust ON t.customer_id = cust.id
      ORDER BY t.created_at DESC
      LIMIT 10
    `);

    // Get daily revenue for last 7 days
    const dailyRevenue = await pool.query(`
      SELECT
        DATE(created_at) as date,
        COUNT(*) as transaction_count,
        SUM(amount) as revenue
      FROM card_transactions
      WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'
      GROUP BY DATE(created_at)
      ORDER BY date DESC
    `);

    res.json({
      data: {
        statistics: stats.rows[0],
        recent_transactions: recentTransactions.rows,
        daily_revenue: dailyRevenue.rows
      }
    });
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get transaction analytics
app.get('/api/analytics/transactions', async (req, res) => {
  try {
    const { period = '7days' } = req.query;

    let interval = '7 days';
    if (period === '30days') interval = '30 days';
    if (period === '90days') interval = '90 days';

    const result = await pool.query(`
      SELECT
        DATE(created_at) as date,
        transaction_type,
        COUNT(*) as count,
        SUM(amount) as total_amount
      FROM card_transactions
      WHERE created_at >= CURRENT_DATE - INTERVAL '${interval}'
      GROUP BY DATE(created_at), transaction_type
      ORDER BY date DESC, transaction_type
    `);

    res.json({ data: result.rows });
  } catch (error) {
    console.error('Error fetching analytics:', error);
    res.status(500).json({ error: error.message });
  }
});

// ==================== BRANCHES API ====================

// Get all branches
app.get('/api/branches', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM branches ORDER BY created_at DESC');
    res.json({ data: result.rows, total: result.rowCount });
  } catch (error) {
    console.error('Error fetching branches:', error);
    res.status(500).json({ error: error.message });
  }
});

// Create new branch
app.post('/api/branches', async (req, res) => {
  try {
    const { name, code, address, city, country, manager_name, manager_phone } = req.body;

    if (!name || !code) {
      return res.status(400).json({ error: 'name and code are required' });
    }

    const result = await pool.query(
      `INSERT INTO branches (name, code, address, city, country, manager_name, manager_phone)
       VALUES ($1, $2, $3, $4, $5, $6, $7)
       RETURNING *`,
      [name, code, address, city, country, manager_name, manager_phone]
    );

    res.status(201).json({ data: result.rows[0], message: 'Branch created successfully' });
  } catch (error) {
    if (error.code === '23505') {
      return res.status(400).json({ error: 'Branch code already exists' });
    }
    console.error('Error creating branch:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update branch
app.put('/api/branches/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, code, address, city, country, manager_name, manager_phone, status } = req.body;

    const result = await pool.query(
      `UPDATE branches
       SET name = COALESCE($1, name),
           code = COALESCE($2, code),
           address = COALESCE($3, address),
           city = COALESCE($4, city),
           country = COALESCE($5, country),
           manager_name = COALESCE($6, manager_name),
           manager_phone = COALESCE($7, manager_phone),
           status = COALESCE($8, status),
           updated_at = NOW()
       WHERE id = $9
       RETURNING *`,
      [name, code, address, city, country, manager_name, manager_phone, status, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Branch not found' });
    }

    res.json({ data: result.rows[0], message: 'Branch updated successfully' });
  } catch (error) {
    console.error('Error updating branch:', error);
    res.status(500).json({ error: error.message });
  }
});

// Delete branch
app.delete('/api/branches/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await pool.query(
      'DELETE FROM branches WHERE id = $1 RETURNING *',
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Branch not found' });
    }

    res.json({ message: 'Branch deleted successfully' });
  } catch (error) {
    console.error('Error deleting branch:', error);
    res.status(500).json({ error: error.message });
  }
});

// ==================== MOBILE MONEY TOP-UP API ====================

// Initiate top-up with MTN/Airtel
app.post('/api/topup/initiate', async (req, res) => {
  try {
    const { card_uid, customer_id, amount, payment_method, phone_number } = req.body;

    if (!card_uid || !amount || !payment_method || !phone_number) {
      return res.status(400).json({
        error: 'card_uid, amount, payment_method, and phone_number are required'
      });
    }

    // Validate payment method
    if (!['mtn', 'airtel'].includes(payment_method.toLowerCase())) {
      return res.status(400).json({
        error: 'payment_method must be either "mtn" or "airtel"'
      });
    }

    // Generate unique reference
    const payment_reference = `TOP${Date.now()}${Math.random().toString(36).substring(2, 9).toUpperCase()}`;

    // Insert top-up record
    const result = await pool.query(
      `INSERT INTO top_ups (card_uid, customer_id, amount, payment_method, payment_reference, payment_provider, status)
       VALUES ($1, $2, $3, $4, $5, $6, 'pending')
       RETURNING *`,
      [card_uid, customer_id, amount, payment_method, payment_reference, payment_method.toUpperCase()]
    );

    // In a real implementation, you would make an API call to MTN/Airtel here
    // For now, we'll simulate a successful request
    const topup = result.rows[0];

    res.status(201).json({
      data: topup,
      message: `Top-up request sent to ${payment_method.toUpperCase()}. Please check your phone for the payment prompt.`,
      instructions: {
        mtn: 'Check your MTN mobile money for a payment prompt. Enter your PIN to complete.',
        airtel: 'Check your Airtel Money for a payment prompt. Enter your PIN to complete.'
      }[payment_method.toLowerCase()],
      mock_info: {
        note: 'In production, this would trigger actual mobile money API',
        reference: payment_reference,
        amount: amount,
        phone: phone_number
      }
    });
  } catch (error) {
    console.error('Error initiating top-up:', error);
    res.status(500).json({ error: error.message });
  }
});

// Mobile Money callback (webhook) - called by MTN/Airtel when payment completes
app.post('/api/topup/callback', async (req, res) => {
  const client = await pool.connect();

  try {
    const { payment_reference, status, transaction_id, callback_data } = req.body;

    if (!payment_reference) {
      return res.status(400).json({ error: 'payment_reference is required' });
    }

    await client.query('BEGIN');

    // Get top-up record
    const topupResult = await client.query(
      'SELECT * FROM top_ups WHERE payment_reference = $1',
      [payment_reference]
    );

    if (topupResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Top-up reference not found' });
    }

    const topup = topupResult.rows[0];

    if (status === 'success' || status === 'completed') {
      // Update top-up status
      await client.query(
        `UPDATE top_ups
         SET status = 'completed',
             callback_data = $1,
             completed_at = NOW()
         WHERE payment_reference = $2`,
        [JSON.stringify(callback_data || req.body), payment_reference]
      );

      // Get card current balance
      const cardResult = await client.query(
        'SELECT * FROM nfc_cards WHERE card_uid = $1',
        [topup.card_uid]
      );

      if (cardResult.rows.length > 0) {
        const card = cardResult.rows[0];
        const balanceBefore = parseFloat(card.balance);
        const balanceAfter = balanceBefore + parseFloat(topup.amount);

        // Create top-up transaction
        await client.query(
          `INSERT INTO card_transactions
           (card_uid, customer_id, transaction_type, amount, balance_before, balance_after, payment_method, payment_provider, reference_number, description)
           VALUES ($1, $2, 'topup', $3, $4, $5, $6, $7, $8, $9)`,
          [
            topup.card_uid,
            topup.customer_id,
            topup.amount,
            balanceBefore,
            balanceAfter,
            topup.payment_method,
            topup.payment_provider,
            payment_reference,
            `Mobile Money Top-Up via ${topup.payment_provider}`
          ]
        );

        // Update card balance
        await client.query(
          'UPDATE nfc_cards SET balance = $1, last_used_at = NOW() WHERE card_uid = $2',
          [balanceAfter, topup.card_uid]
        );
      }

      await client.query('COMMIT');
      res.json({
        success: true,
        message: 'Top-up completed successfully',
        data: { payment_reference, amount: topup.amount }
      });
    } else {
      // Payment failed
      await client.query(
        `UPDATE top_ups
         SET status = 'failed',
             callback_data = $1
         WHERE payment_reference = $2`,
        [JSON.stringify(callback_data || req.body), payment_reference]
      );

      await client.query('COMMIT');
      res.json({
        success: false,
        message: 'Top-up failed',
        data: { payment_reference }
      });
    }
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error processing callback:', error);
    res.status(500).json({ error: error.message });
  } finally {
    client.release();
  }
});

// Manual top-up completion (for testing/demo)
app.post('/api/topup/complete/:reference', async (req, res) => {
  const client = await pool.connect();

  try {
    const { reference } = req.params;

    await client.query('BEGIN');

    const topupResult = await client.query(
      'SELECT * FROM top_ups WHERE payment_reference = $1',
      [reference]
    );

    if (topupResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Top-up reference not found' });
    }

    const topup = topupResult.rows[0];

    if (topup.status === 'completed') {
      await client.query('ROLLBACK');
      return res.status(400).json({ error: 'Top-up already completed' });
    }

    // Update top-up status
    await client.query(
      `UPDATE top_ups
       SET status = 'completed',
           completed_at = NOW()
       WHERE payment_reference = $1`,
      [reference]
    );

    // Get card
    const cardResult = await client.query(
      'SELECT * FROM nfc_cards WHERE card_uid = $1',
      [topup.card_uid]
    );

    if (cardResult.rows.length > 0) {
      const card = cardResult.rows[0];
      const balanceBefore = parseFloat(card.balance);
      const balanceAfter = balanceBefore + parseFloat(topup.amount);

      // Create transaction
      await client.query(
        `INSERT INTO card_transactions
         (card_uid, customer_id, transaction_type, amount, balance_before, balance_after, payment_method, payment_provider, reference_number, description)
         VALUES ($1, $2, 'topup', $3, $4, $5, $6, $7, $8, $9)`,
        [
          topup.card_uid,
          topup.customer_id,
          topup.amount,
          balanceBefore,
          balanceAfter,
          topup.payment_method,
          topup.payment_provider,
          reference,
          `Mobile Money Top-Up via ${topup.payment_provider} (Manual Completion)`
        ]
      );

      // Update card balance
      await client.query(
        'UPDATE nfc_cards SET balance = $1, last_used_at = NOW() WHERE card_uid = $2',
        [balanceAfter, topup.card_uid]
      );
    }

    await client.query('COMMIT');
    res.json({
      success: true,
      message: 'Top-up completed successfully',
      data: {
        payment_reference: reference,
        amount: topup.amount,
        new_balance: parseFloat(cardResult.rows[0].balance) + parseFloat(topup.amount)
      }
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error completing top-up:', error);
    res.status(500).json({ error: error.message });
  } finally {
    client.release();
  }
});

// Get top-up history
app.get('/api/topup/history', async (req, res) => {
  try {
    const { card_uid, customer_id, status } = req.query;

    let query = `
      SELECT t.*, c.card_uid, cust.name as customer_name, cust.phone as customer_phone
      FROM top_ups t
      LEFT JOIN nfc_cards c ON t.card_uid = c.card_uid
      LEFT JOIN customers cust ON t.customer_id = cust.id
    `;
    const params = [];
    const conditions = [];

    if (card_uid) {
      conditions.push(`t.card_uid = $${params.length + 1}`);
      params.push(card_uid);
    }
    if (customer_id) {
      conditions.push(`t.customer_id = $${params.length + 1}`);
      params.push(customer_id);
    }
    if (status) {
      conditions.push(`t.status = $${params.length + 1}`);
      params.push(status);
    }

    if (conditions.length > 0) {
      query += ' WHERE ' + conditions.join(' AND ');
    }

    query += ' ORDER BY t.created_at DESC LIMIT 100';

    const result = await pool.query(query, params);
    res.json({ data: result.rows, total: result.rowCount });
  } catch (error) {
    console.error('Error fetching top-up history:', error);
    res.status(500).json({ error: error.message });
  }
});

// ==================== USSD API ====================

// USSD main menu
app.post('/api/ussd', async (req, res) => {
  try {
    const { sessionId, serviceCode, phoneNumber, text } = req.body;

    let response = '';

    if (text === '') {
      // Main menu
      response = `CON Welcome to Kiaan POS
1. Check Card Balance
2. Top-Up Card
3. Transaction History
4. Support`;
    } else if (text === '1') {
      // Check balance - ask for card ID
      response = `CON Enter your Card ID (last 6 digits on card):`;
    } else if (text.startsWith('1*')) {
      // Get balance
      const cardId = text.split('*')[1];

      try {
        const result = await pool.query(
          `SELECT c.*, cust.name
           FROM nfc_cards c
           LEFT JOIN customers cust ON c.customer_id = cust.id
           WHERE c.card_uid LIKE $1 AND cust.phone = $2`,
          [`%${cardId}`, phoneNumber]
        );

        if (result.rows.length > 0) {
          const card = result.rows[0];
          response = `END Your balance: UGX ${parseFloat(card.balance).toLocaleString()}
Status: ${card.status}
Last used: ${card.last_used_at ? new Date(card.last_used_at).toLocaleString() : 'Never'}`;
        } else {
          response = `END Card not found or not linked to this phone number.`;
        }
      } catch (error) {
        response = `END Error retrieving balance. Please try again.`;
      }
    } else if (text === '2') {
      // Top-up menu
      response = `CON Top-Up Card
1. MTN Mobile Money
2. Airtel Money`;
    } else if (text.startsWith('2*1') || text.startsWith('2*2')) {
      const parts = text.split('*');

      if (parts.length === 2) {
        // Ask for card ID
        response = `CON Enter your Card ID (last 6 digits):`;
      } else if (parts.length === 3) {
        // Ask for amount
        response = `CON Enter amount to top-up (UGX):`;
      } else if (parts.length === 4) {
        // Process top-up
        const provider = parts[1] === '1' ? 'MTN' : 'Airtel';
        const cardId = parts[2];
        const amount = parts[3];

        try {
          const cardResult = await pool.query(
            `SELECT c.* FROM nfc_cards c
             LEFT JOIN customers cust ON c.customer_id = cust.id
             WHERE c.card_uid LIKE $1 AND cust.phone = $2`,
            [`%${cardId}`, phoneNumber]
          );

          if (cardResult.rows.length > 0) {
            const card = cardResult.rows[0];
            const reference = `USSD${Date.now()}`;

            await pool.query(
              `INSERT INTO top_ups (card_uid, customer_id, amount, payment_method, payment_reference, payment_provider, status)
               VALUES ($1, $2, $3, $4, $5, $6, 'pending')`,
              [card.card_uid, card.customer_id, amount, provider.toLowerCase(), reference, provider]
            );

            response = `END Top-up request sent!
Provider: ${provider}
Amount: UGX ${amount}
Reference: ${reference}

You will receive a payment prompt from ${provider} Mobile Money shortly. Enter your PIN to complete.`;
          } else {
            response = `END Card not found or not linked to your phone number.`;
          }
        } catch (error) {
          response = `END Error processing top-up. Please try again.`;
        }
      }
    } else if (text === '3') {
      // Transaction history - ask for card ID
      response = `CON Enter your Card ID to view history:`;
    } else if (text.startsWith('3*')) {
      const cardId = text.split('*')[1];

      try {
        const result = await pool.query(
          `SELECT t.* FROM card_transactions t
           LEFT JOIN nfc_cards c ON t.card_uid = c.card_uid
           LEFT JOIN customers cust ON c.customer_id = cust.id
           WHERE c.card_uid LIKE $1 AND cust.phone = $2
           ORDER BY t.created_at DESC
           LIMIT 5`,
          [`%${cardId}`, phoneNumber]
        );

        if (result.rows.length > 0) {
          let historyText = `END Recent Transactions:\n`;
          result.rows.forEach((txn, idx) => {
            historyText += `${idx + 1}. ${txn.transaction_type.toUpperCase()} - UGX ${parseFloat(txn.amount).toLocaleString()} (${new Date(txn.created_at).toLocaleDateString()})\n`;
          });
          response = historyText;
        } else {
          response = `END No transactions found for this card.`;
        }
      } catch (error) {
        response = `END Error retrieving history. Please try again.`;
      }
    } else if (text === '4') {
      response = `END Kiaan POS Support
Call: +256 700 000 000
Email: support@kiaan.com
Hours: 24/7`;
    } else {
      response = `END Invalid option. Please try again by dialing ${serviceCode}`;
    }

    res.set('Content-Type', 'text/plain');
    res.send(response);
  } catch (error) {
    console.error('USSD error:', error);
    res.set('Content-Type', 'text/plain');
    res.send('END Service temporarily unavailable. Please try again later.');
  }
});

// ==================== HEALTH CHECK ====================

app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    database: 'connected'
  });
});

app.get('/', (req, res) => {
  res.json({
    message: 'Kiaan POS API',
    version: '1.0.0',
    endpoints: {
      customers: '/api/customers',
      cards: '/api/cards',
      transactions: '/api/transactions',
      dashboard: '/api/dashboard/stats',
      analytics: '/api/analytics/transactions',
      branches: '/api/branches'
    }
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`\nüöÄ Kiaan POS API Server running on port ${PORT}`);
  console.log(`üìä API Documentation: http://localhost:${PORT}/`);
  console.log(`üè• Health check: http://localhost:${PORT}/health`);
  console.log('\n‚úÖ Ready to accept requests!\n');
});

module.exports = app;
